
#Calling this thing swagger is just convention; the loader (connexion in flask) just needs to know to load this file
#localhost:8000/api/ui  shows the ui for ur stuff.

openapi: 3.0.0
info:
  title: "RP Flask REST API"
  description: "A test API for me to learn what goes where. The topic is completely unrelated to my contexto but idk flask or anything so time to learn!"
  version: "1.0.0"
#comments are like this. We're probably going to need a lot of these.
servers:
  - url: "/api"

#Components are kind of like classes. These can have schemas which are ways to check if the data is chilling
components:
  schemas:
    Person:
      type: "object" #Schema checks that the person is an object w/ lname and might have a String fname. If that stuff is violated it yells at u.
      required:
        - lname
      properties:
        fname:
          type: "string"
        lname:
          type: "string"

paths: #This defines all the things you can do with the API. So if u visit the /people link(endpoint), you can get
  /people: #This is an endpoint: The destination for the URL. When you run there, it does people.read_all
    get:
      operationId: "people.read_all" #the python fxn that gets called when the request is thinged.
      tags: #Tags are optional fields to gropu/label. Documentation stuff which means im prolly gonna ignore it /hj
        - "People"
      summary: "Read the list of people" #Flask's UI display text 
      responses: 
        "200":
          description: "Successfully read people list" #Possible exit code statuses
    post:
        operationId: "people.create"
        tags:
          - People
        summary: "Create a person"
        requestBody:
            description: "Person to create"
            required: True
            content:
              application/json:
                schema:
                  x-body-name: "person"
                  $ref: "#/components/schemas/Person"
        responses:
          "201":
            description: "Successfully created person"

  /people/{lname}: #This is a different endpoint, pass stuff in as URL parameter CASE SENSITIVE
    get:
      operationId: "people.read_one" #Will see that the corresponding python fxn takes one param and jam the lname in as the param
      tags:
        - People
      summary: "Read one person"
      parameters: #Parameters: instead of redefinig lnames, it points u to the definition in components
        - $ref: "#/components/parameters/lname"
      responses:
        "200":
          description: "Successfully read person"
    put:
      tags:
        - People
      operationId: "people.update"
      summary: "Update a person"
      parameters:
        - $ref: "#/components/parameters/lname"
      responses:
        "200":
          description: "Successfully updated person"
      requestBody:
        content:
          application/json:
            schema:
              x-body-name: "person"
              $ref: "#/components/schemas/Person"
    delete:
      tags:
        - People
      operationId: "people.delete"
      summary: "Delete a person"
      parameters:
        - $ref: "#/components/parameters/lname"
      responses:
        "204":
          description: "Successfully deleted person"